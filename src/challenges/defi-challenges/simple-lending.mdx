---
name: Simple Lending
index: 3
level: 3
website: "https://github.com/LevelUpWeb3/SimpleTokenSwap-Challenge"
summary: Introduction to implementing a simple token swap contract by understanding Uniswap swap function.
heroImage: "/images/level-up-preview.png"
labels: ["DeFi"]
---

import ContentCopy from "src/components/ContentCopy";

# Simple Lending

If you haven't completed the Token Swap challenge yet, check it out [here](https://www.levelup.xyz/challenges/simple-token-swap)!

Let's take a step further and dive into another core DeFi primitive, lending. Aave is one of the top protocols, securing billions in assets. Let's learn how to earn yield by lending through smart contracts.

In this challenge, you'll implement a contract that deposits into Aave pools on your behalf. You'll also be able to withdraw your supplied tokens along with the earned rewards.

## Objective

Your task is to:
1. Develop your own contract with `deposit` and `withdraw` functionalities.
2. Deploy it to Scroll Sepolia Testnet.
3. And finally verify it.
 
If you need help with using a smart contract framework for completing this challenge, the [Level Up: Build with Foundry](https://www.levelup.xyz/content/level-up-foundry) guide might be a helpful start!

If you get stuck, feel free to ask for help in [Level Up Telegram group](https://t.me/+PdNbk5milo1mMTAy).

<ContentCopy code={`// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

// In this example, the DataTypes library is used to query the AToken address that corresponds DAI
// Later, we will use the getReserveData that will return a ReserveData object.  
// Aave docs: https://docs.aave.com/developers/core-contracts/pool#getreservedata
library DataTypes {
  struct ReserveConfigurationMap {
    uint256 data;
  }

  struct ReserveData {
    ReserveConfigurationMap configuration;
    uint128 liquidityIndex;
    uint128 currentLiquidityRate;
    uint128 variableBorrowIndex;
    uint128 currentVariableBorrowRate;
    uint128 currentStableBorrowRate;
    uint40 lastUpdateTimestamp;
    uint16 id;
    address aTokenAddress;
    address stableDebtTokenAddress;
    address variableDebtTokenAddress;
    address interestRateStrategyAddress;
    uint128 accruedToTreasury;
    uint128 unbacked;
    uint128 isolationModeTotalDebt;
  }
}

// IPool is the main AAVE interface exposed to users, the most notable functions are borrow, supply and withdraw
// AAVE docs: https://docs.aave.com/developers/core-contracts/pool
interface IPool {
    function supply(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode) external;

    function withdraw(
        address asset,
        uint256 amount,
        address to) external returns (uint256);

    function getReserveData(
        address asset) external view returns (DataTypes.ReserveData memory);
}

// ERC20 interface used to interact with the staking token, which is DAI on this tutorial
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

// This contract acts as a proxy to earn yield on AAVE. It can be used seamlessly on the background on
// a variety of contexts such as auctions, DAO treasuries, lotteries, etc...
contract AaveLender {
    // AAVE Pool Address, depolyed on Scroll Sepolia at 0x48914C788295b5db23aF2b5F0B3BE775C4eA9440
    address public immutable AAVE_POOL_ADDRESS = 0x48914C788295b5db23aF2b5F0B3BE775C4eA9440;
    // In this example we will stake DAI, but any ERC20 supported by AAVE can be also used
    address public immutable STAKED_TOKEN_ADDRESS = 0x7984E363c38b590bB4CA35aEd5133Ef2c6619C40;

    // Function that stakes DAI and lends it on the background
    function stake(uint amount) public {
      ...
      // 1. Transfer the DAI tokens to be deposited into this contract
      // 2. Allow (or approve) the Aave Pool contract so it can manage the deposited DAI tokens
      // 3. Call the supply function in the Aave Pool on behalf of the transaction sender
    }

    // Every user is able to unstake the exact amount it has staked, all the yield generated by AAVE will go the Owner
    function withdraw(uint amount) public {
      ...
      // 1. Transfer the aDAI token (The AToken) to be withdrawn (notice you will need to get the aDAI token address beforehand)
      // 2. Allow (or approve) the Aave Pool contract so it can manage the deposited aDAI tokens
      // 3. Call the withdraw function so the the sender recieves the DAI back
    }
}`} language="solidity"/>

## Supply, withdraw, borrow and repay

These are the 4 core functions in the Aave protocol.

- **Supply:** Lend tokens by depositing them into the Aave Pool.
- **Withdraw:** Retrieve your supplied tokens along with any earned rewards.
- **Borrow:** Borrow the tokens you need.
- **Repay:** Pay back the borrowed tokens along with the interest.

During this challenge we will focus only on the `supply` and `withdraw` functions.

## AToken the Aave ERC20 token standard

When you `supply` (lend) a token in Aave you get an AToken as a receipt. For example, if you deposit `10 DAI` into the Aave Pool, you will get `10 aDAI` back to your wallet. This token tracks how much you supplied and how much yield you earned so when you `withdraw` your tokens you get your fair share of rewards.

For example, if you deposit `10 DAI` now you will recieve `10 aDAI` immediatly. Fast forward many blocks later, your `10 aDAI` will turn into `11 aDAI`, at this point you can give back your `11 aDAI` to get `11 DAI` to your wallet earning a `1 DAI` profit.

The ATokens use the Rebase functionalities, this makes them very easy to use and for us users very easy to keep track of our earnings.

## Rebase Token? How does it work?

Rebase have a special implementation of tokens, fully compatible with the ERC20 standard. The different part in a rebase token is that is has a variable cappable of affecting all holder balances. Let's take as an example the `balanceOf()` function part of the ERC20 standard, internally this is how it usually looks like:

```latex
balanceOf(x) = balances[x]
```

Notice how the rebase token adds the `RATE` variable multiplication (or division in some cases but leading to the same results).

```latex
balanceOf(x) = sharesOf(x) Â· RATE
```

Here;

- _sharesOf_ denotes the "fragments" 
- _RATE_ a variable that is able to distribute rewards equally accross all the holders

This allows the protocol to distribute rewards very cheaply and users to know exactly how much rewards they have earned, they just need to check their AToken balances that will change automatically over time without them needing to do any kind of interaction.

## The `supply()` function

<ContentCopy
  code={`function supply(
  address asset,
  uint256 amount,
  address onBehalfOf,
  uint16 referralCode) external;`} language="solidity"
/>

- **asset:** Assset being deposited into the Pool, in this challenge we will use DAI.
- **amount:** Ammount of `asset` being deposited, in wei.
- **onBehalfOf:** Address that will receive the ATokens.
- **referalCode:** Used only for Aave thrid party integrations, on this challenge you can keep it as 0.

## The `withdraw()` function

<ContentCopy
  code={`function withdraw(
  address asset,
  uint256 amount,
  address to) external returns (uint256);`} language="solidity"
/>

- **asset:** Underlying assset being withdrawn from the Pool. Is is not the AToken, in our case this is the DAI contract address. 
- **amount:** Ammount of `asset` being withdrawn, in wei.
- **to:** Account that will receive the tokens.

## Get the AToken address thorugh `getReserveData()`

<ContentCopy
  code={`ISwapRouter.ExactInputSingleParamsIPool(AAVE_POOL_ADDRESS).getReserveData(STAKED_TOKEN_ADDRESS).aTokenAddress`} language="solidity"
/>

In order to complete this Challenge you will need to know the staked token address

## Build the Contract

1. Implement the deposit function

    a. Transfer the DAI tokens to be deposited into this contract

    b. Allow (or approve) the Aave Pool contract so it can manage the deposited DAI tokens

    c. Call the supply function in the Aave Pool on behalf of the transaction sender

2. Implement the deposit function

    a. Transfer the aDAI token (The AToken) to be withdrawn (notice you will need to get the aDAI token address beforehand)

    b. Allow (or approve) the Aave Pool contract so it can manage the deposited aDAI tokens

    c. Call the withdraw function so the the sender recieves the DAI back

## Further Reading

1. [AAve v3 official documentation](https://docs.aave.com/developers/getting-started/contracts-overview)
2. [About the AToken](https://docs.aave.com/developers/tokens/atoken)