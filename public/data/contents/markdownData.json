[
  {
    "id": "exploring-solidity-objects-address-part-1",
    "name": "Exploring Solidity Objects: Address - Part 1",
    "index": 1,
    "summary": "Dive into the world of Solidity in pursuit of leveling up! Starting with Address object.",
    "author": "RH",
    "authorIcon": "https://pbs.twimg.com/profile_images/1751242830398287872/8VKShh46.jpg",
    "authorLink": "https://x.com/rh_bdl",
    "published": "Jul 03, 2024",
    "readTime": "3 min read",
    "labels": [
      "Smart Contract"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    a: \"a\",\n    h2: \"h2\",\n    strong: \"strong\",\n    h3: \"h3\",\n    em: \"em\"\n  }, _provideComponents(), props.components), {ContentCopy} = _components;\n  if (!ContentCopy) _missingMdxReference(\"ContentCopy\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"If you have been tinkering with Solidity, you might have used or came across the \", _jsx(_components.code, {\n        children: \"address\"\n      }), \" object in Solidity. Common use cases of this object includes reading \", _jsx(_components.code, {\n        children: \"address\"\n      }), \" balance, and sending tokens.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this article, we will explore the different members of \", _jsx(_components.code, {\n        children: \"address\"\n      }), \" while referencing Solidity's \", _jsx(_components.a, {\n        href: \"https://docs.soliditylang.org/en/latest/cheatsheet.html#members-of-address\",\n        children: \"docs\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"1. Balance\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The balance member provides access to read balance of address in Wei (1 Ether = 10^18 Wei).\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `function retrieveBalance() public view returns (uint256) {\n    //returns ETH balance of deployed contract in Wei\n    return address(this).balance;\n}\n\nfunction retrieveUserBalance(address user) public view returns (uint256) {\n    //returns ETH balance of user's address in Wei\n    return address(user).balance;\n}`,\n      language: \"solidity\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"retrieveBalance()\"\n      }), \" function is an example of a gotcha that catches new Solidity devs off-guard. It is not unusual to assume that \", _jsx(_components.code, {\n        children: \"address(this).balance\"\n      }), \" would return the balance of our address. In reality, it is the balance of the smart contract itself that is read.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"2. Code\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"code\"\n      }), \" member allows us to query the deployed contract’s bytecode information.\"]\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `function retrieveCode() public view returns (bytes memory) {\n    //returns EVM bytecode\n    return address(this).code;\n}\n\nfunction retrieveCodehash() public view returns (bytes32) {\n    //returns Keccak-256 hash of the EVM bytecode\n    return address(this).codehash;\n}`,\n      language: \"solidity\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"retrieveCode()\"\n      }), \" queries the EVM bytecode and in this example, the output looks something like this “0x60806040…4300081a0033”.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is useful for contract verification purposes. \", _jsx(_components.a, {\n        href: \"https://etherscan.io/token/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code\",\n        children: \"Here\"\n      }), \" is an example of WETH’s deployed contract in Etherscan. Scroll below to see the Deployed Bytecode’s output.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"retrieveCodehash()\"\n      }), \" simply provides the Keccak-256 hash of the output. It provides a more efficient way to verify the deployed contract as it is cheaper in terms of gas costs.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"3. Transfer, Send & Call\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"• Transfer & Send\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Typically invoked for sending Ether. Level Up has also put together a \", _jsx(_components.a, {\n        href: \"(https://www.levelupweb3.xyz/solidity/transacting-ether)\",\n        children: \"guide\"\n      }), \" covering these members. The section below covers the output/responses when using these members.\"]\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `function transferKeyword(uint256 ethAmount) public {\n    // NOT recommended for sending Ether\n    // Reverts with error if txn fails\n    payable(address(this)).transfer(ethAmount);\n}\n\nfunction sendKeyword(uint256 ethAmount) public returns (bool) {\n    // NOT recommended for sending Ether\n    // Reverts with bool: \"false\" if txn fails\n    return payable(address(this)).send(ethAmount);\n}`,\n      language: \"solidity\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"transfer\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"send\"\n      }), \" members are \", _jsx(_components.em, {\n        children: \"not\"\n      }), \" recommended for sending Ether. Take note on the expected responses if you plan to use them.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In situations of failed transactions, \", _jsx(_components.code, {\n        children: \"transfer\"\n      }), \" reverts with an error while \", _jsx(_components.code, {\n        children: \"send\"\n      }), \" returns a boolean value of \", _jsx(_components.code, {\n        children: \"false\"\n      }), \" (but the transaction will be successful).\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.strong, {\n        children: [\"Note: \", _jsx(_components.code, {\n          children: \"send\"\n        }), \" updates state, but \", _jsx(_components.code, {\n          children: \"transfer\"\n        }), \" does not. Both members still consume gas regardless of the transaction status.\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"• Call\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `function callKeyword(uint256 ethAmount) public {\n    // RECOMMENDED method to send Ether\n    // Passing blanks (\"\") because the example below shows empty calldata\n    (bool sent, ) = address(this).call{value: ethAmount}(\"\");\n    require(sent, \"Failed to send Ether\");\n}`,\n      language: \"solidity\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"call\"\n      }), \" is recommended due to its \", _jsx(_components.a, {\n        href: \"https://forum.openzeppelin.com/t/should-we-never-use-the-transfer-function/38445\",\n        children: \"flexibility for sending Ether\"\n      }), \". It also allows you to pass arguments if interacting with custom functions that require any parameters.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This concludes part 1. In the next part, we will cover other members of the address object such as \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \". Stay tuned!\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",
      "frontmatter": {},
      "scope": {}
    }
  },
  {
    "id": "exploring-solidity-objects-address-part-2",
    "name": "Exploring Solidity Objects: Address - Part 2",
    "index": 2,
    "summary": "Dive into the world of Solidity in pursuit of leveling up! Venturing into delegatecall and staticcall functions!",
    "author": "RH",
    "authorIcon": "https://pbs.twimg.com/profile_images/1751242830398287872/8VKShh46.jpg",
    "authorLink": "https://x.com/rh_bdl",
    "published": "Aug 06, 2024",
    "readTime": "6 min read",
    "labels": [
      "Smart Contract"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    code: \"code\",\n    strong: \"strong\",\n    h2: \"h2\",\n    em: \"em\"\n  }, _provideComponents(), props.components), {ContentCopy, YoutubeEmbed} = _components;\n  if (!ContentCopy) _missingMdxReference(\"ContentCopy\", true);\n  if (!YoutubeEmbed) _missingMdxReference(\"YoutubeEmbed\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"In \", _jsx(_components.a, {\n        href: \"https://rhbdl.substack.com/p/exploring-solidity-objects-address?r=1v972g\",\n        children: \"Part 1\"\n      }), \", we explored different \", _jsx(_components.code, {\n        children: \"address\"\n      }), \" members and their use cases. While the previous article explored scenarios involving sending Ether, it is helpful to know that the functionalities extend beyond that.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For instance, the \", _jsx(_components.code, {\n        children: \"call\"\n      }), \" function is a low-level function which has the capability to invoke any function on any target contract by specifying the function signature and arguments in the \\\"data\\\" parameter. \", _jsx(_components.strong, {\n        children: \"(Security Note: call never reverts. It is our responsibility to handle unsuccessful transaction errors.)\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now, let's delve into the final two members of the address object: \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \". These members are also interchangeably referred as functions - particularly when describing their role in code execution through invocation.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The underlying concept of \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \" is relatively straightforward, as they are essentially specialized variants of the \", _jsx(_components.code, {\n        children: \"call\"\n      }), \" function.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"1. delegatecall\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This function allows state modifying instructions while preserving the original contract's context (storage, sender address, and value).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"At this point, you might be wondering about the terminology “delegatecall”. How exactly are the function calls “delegated”? Or rather, what is the mode of “delegation” here?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's utilise the code below to answer these questions!\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `pragma solidity ^0.8.24;\n\ncontract Caller {\nuint256 public value;\n\n    function setVars(uint256 _value) public payable {\n        value = _value;\n    }\n\n}\n\ncontract DelegateCaller {\nuint256 public value;\n\n    function setVars(address _callerContract, uint256 _value) public payable {\n        // Caller delegated its setVars() function to DelegateCaller Contract\n        (bool success, ) = _callerContract.delegatecall(\n            abi.encodeWithSignature(\"setVars(uint256)\", _value)\n        );\n        if (!success) revert(\"Failed\");\n    }\n\n}`,\n      language: \"solidity\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When \", _jsx(_components.code, {\n        children: \"setVars()\"\n      }), \" is called in DelegateCaller contract, the \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \" invokes the \", _jsx(_components.code, {\n        children: \"setVars()\"\n      }), \" function in the Caller contract but in the DelegateCaller execution environment.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Thus, Caller contract has effectively delegated its function to DelegateCaller contract.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's explore further using the video below! (\", _jsxs(_components.strong, {\n        children: [\"Watch what happens when \", _jsx(_components.code, {\n          children: \"setVars()\"\n        }), \" was called in DelegateCaller contract.\"]\n      }), \" Observe how the \", _jsx(_components.code, {\n        children: \"value\"\n      }), \" variables change in the context of Caller and DelegateCaller contract.)\"]\n    }), \"\\n\", _jsx(YoutubeEmbed, {\n      id: \"IUhr8N_WroI\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.em, {\n        children: [\"Were you able to identify the contract that had its \", _jsx(_components.code, {\n          children: \"value\"\n        }), \" variable updated when \", _jsx(_components.code, {\n          children: \"delegatecall\"\n        }), \" was invoked?\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This behavior might seem redundant at first when we can simply use \", _jsx(_components.code, {\n        children: \"call\"\n      }), \" function. However, \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \" enables use cases such as for proxy contracts - where only the implementation contract (i.e. Uniswap V2, V3) is upgraded to preserve the context of the proxy contract.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Having explored the complexities of \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \", let’s proceed to explore \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" which is relatively simpler!\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"2. staticcall\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In general, \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" does not allow any state modifying instructions or capability to send ether. It will revert if there are any state changes during the function invocation.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"At a low-level, it disallows opcodes such as CREATE, SSTORE, SELFDESTRUCT, and few \", _jsx(_components.a, {\n        href: \"https://www.evm.codes/#fa?fork=cancun\",\n        children: \"others\"\n      }), \". Personally, I view \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" as a safer variant of the call function to read state.\"]\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"/images/contents/staticcall.png\",\n        alt: \"staticcall example\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsxs(_components.em, {\n          children: [\"Figure 1: \", _jsx(_components.code, {\n            children: \"staticcall\"\n          }), \" example\"]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the example above, notice how the \", _jsx(_components.code, {\n        children: \"value\"\n      }), \" variable for StaticCaller contract did not change. It remains as “0” even when Caller contract has been updated to store “100” in its \", _jsx(_components.code, {\n        children: \"value\"\n      }), \" variable. Unlike \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \" which allows state modifying instruction, \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" only reads state of the target contract (Caller contract in this example).\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As a treat, I have also included a function \", _jsx(_components.code, {\n        children: \"setVars()\"\n      }), \" which purposefully calls a state modifying function from the target contract to simulate transaction failure. Watch the video towards the end to learn what happens when \", _jsx(_components.code, {\n        children: \"success\"\n      }), \" returns false.\"]\n    }), \"\\n\", _jsx(YoutubeEmbed, {\n      id: \"iGQ5z6B1PQw\"\n    }), \"\\n\", _jsx(\"div\", {\n      className: \"text-center\",\n      children: _jsx(_components.p, {\n        children: _jsxs(_components.em, {\n          children: [\"Explore this code further here:\\n\", _jsx(_components.a, {\n            href: \"https://remix.ethereum.org/?#code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVApwcmFnbWEgc29saWRpdHkgXjAuOC4yNDsKCmNvbnRyYWN0IENhbGxlciB7CiAgICB1aW50MjU2IHB1YmxpYyB2YWx1ZTsKCiAgICBmdW5jdGlvbiBzZXRWYXJzKHVpbnQyNTYgX3ZhbHVlKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgdmFsdWUgPSBfdmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gcmVhZFZhbHVlKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludDI1NikgewogICAgICAgIHJldHVybiB2YWx1ZTsKICAgIH0KfQoKY29udHJhY3QgU3RhdGljQ2FsbGVyIHsKICAgIHVpbnQyNTYgcHVibGljIHZhbHVlOwoKICAgIGZ1bmN0aW9uIHNldFZhcnMoYWRkcmVzcyBfY2FsbGVyQ29udHJhY3QsIHVpbnQyNTYgX3ZhbHVlKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgKGJvb2wgc3VjY2VzcywgKSA9IF9jYWxsZXJDb250cmFjdC5zdGF0aWNjYWxsKAogICAgICAgICAgICBhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgic2V0VmFycyh1aW50MjU2KSIsIF92YWx1ZSkKICAgICAgICApOwogICAgICAgIGlmKCFzdWNjZXNzKSByZXZlcnQgKCJFcnJvciBpbiBzdGF0aWNjYWxsIik7CiAgICB9CgogICAgZnVuY3Rpb24gcmVhZFZhcnMoYWRkcmVzcyBfY2FsbGVyQ29udHJhY3QpIHB1YmxpYyB2aWV3IHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICAoLCBieXRlcyBtZW1vcnkgZGF0YSkgPSBfY2FsbGVyQ29udHJhY3Quc3RhdGljY2FsbChhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVhZFZhbHVlKCkiKSk7CiAgICAgICAgcmV0dXJuIGFiaS5kZWNvZGUoZGF0YSwgKHVpbnQyNTYpKTsKICAgIH0KfQ&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.26+commit.8a97fa7a.js\",\n            children: \"staticcall.sol\"\n          })]\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In \", _jsx(_components.a, {\n        href: \"https://ethglobal.com/events/brussels/prizes/scroll\",\n        children: \"ETH CC Brussels\"\n      }), \", Scroll introduced the experimental \", _jsx(_components.a, {\n        href: \"https://ethereum-magicians.org/t/rip-7728-l1sload-precompile/20388\",\n        children: \"L1SLOAD precompile\"\n      }), \" which uses \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" under the hood.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Hackers were able to explore novel methods of resolving ENS address, extending NFT ownership - all on L2. Despite preliminary stage of experimentation, this highlights that the potential opportunities for this function are virtually limitless.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now that you have equipped yourself with an arsenal of knowledge on the \", _jsx(_components.code, {\n        children: \"address\"\n      }), \" object, you are now capable of address-ing (Hehe! Pun intended) more intermediate to advanced level builds. Can't wait to hear all about how you will be using this knowledge to level up your projects.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",
      "frontmatter": {},
      "scope": {}
    }
  },
  {
    "id": "private-smart-contracts-with-solidity-and-circom",
    "name": "Private Smart Contracts with Solidity & Circom",
    "index": 3,
    "summary": "Get started with developing privacy applications by combining Circuits and Smart Contracts.",
    "author": "FilosofiaCodigo",
    "authorIcon": "https://avatars.githubusercontent.com/u/707484?s=96&v=4",
    "authorLink": "https://x.com/FilosofiaCodigo",
    "published": "Sep 04, 2024",
    "readTime": "15 min read",
    "labels": [
      "ZK"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    pre: \"pre\",\n    img: \"img\"\n  }, _provideComponents(), props.components), {ContentCopy} = _components;\n  if (!ContentCopy) _missingMdxReference(\"ContentCopy\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"ZK enables the development of applications with both private data and private execution. This opens the door to many new use cases, like the one we'll create in this guide: an anonymous and secure voting system combining Circom and Solidity.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Circom and dependencies\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you don't have Circom installed yet, install it with the following commands. I'm using node v20, but it should work with other versions as well.\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: ` curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\ngit clone https://github.com/iden3/circom.git\ncd circom\ncargo build --release\ncargo install --path circom\nnpm install -g snarkjs`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We'll also use the Circom libraries where the Poseidon function that we'll be using is located.\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: ` git clone https://github.com/iden3/circomlib.git`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. Public key creation\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The method we will use to conduct anonymous and secure voting is by proving that we are part of a group without revealing our identity. For example, I will vote for the president of Honduras, demonstrating that I am a Honduran without revealing which specific Honduran I am. This is called \\\"proof of inclusion in a set.\\\"\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The most practical way to achieve this in zk and blockchain is through Merkle trees. We will place the voters as leaves in the tree and prove that we are one of them without disclosing which one.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Since the tree is public, we will use a set of public-private key pairs so that each voter can cast their vote only once.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You might wonder if we can use the public keys from our Ethereum wallet (e.g., from MetaMask). In future guides like this one, I'll address that topic just as I did with noir. To reach that point, you'll need the fundamentals from this guide. So stay tuned and follow \", _jsx(_components.a, {\n        href: \"https://x.com/levelupweb3\",\n        children: \"LevelUp on X\"\n      }), \"!\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, let's create the public keys for the following private keys using the circuit privateKeyHasher.circom below:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"111\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"222\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"333\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"444\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"privateKeyHasher.circom\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: ` pragma circom 2.0.0;\n\ninclude \"circomlib/circuits/poseidon.circom\";\n\ntemplate privateKeyHasher() {\n    signal input privateKey;\n    signal output publicKey;\n    component poseidonComponent;\n    poseidonComponent = Poseidon(1);\n    poseidonComponent.inputs[0] <== privateKey;\n    publicKey <== poseidonComponent.out;\n    log(publicKey);\n}\n\ncomponent main = privateKeyHasher();`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"input.json\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `{\n    \"privateKey\": \"111\"\n}`,\n      language: \"json\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Compile and compute the circuit with the commands below, and you'll see the result in the terminal.\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `circom privateKeyHasher.circom --r1cs --wasm --sym --c\nnode privateKeyHasher_js/generate_witness.js privateKeyHasher_js/privateKeyHasher.wasm input.json witness.wtns`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The result of the 4 private keys should be as follows:\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Private key\"\n          }), _jsx(_components.th, {\n            children: \"Public key\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"111\"\n          }), _jsx(_components.td, {\n            children: \"13377623690824916797327209540443066247715962236839283896963055328700043345550\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"222\"\n          }), _jsx(_components.td, {\n            children: \"3370092681714607727019534888747304108045661953819543369463810453568040251648\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"333\"\n          }), _jsx(_components.td, {\n            children: \"19430878135540641438890585969007029177622584902384053006985767702837167003933\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"444\"\n          }), _jsx(_components.td, {\n            children: \"2288143249026782941992289125994734798520452235369536663078162770881373549221\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Is it necessary to do this through Circom? The answer is no. By using Circom, we're performing a lot of unnecessary computation. For now, we're doing it this way to ensure that the implementation of the Poseidon hashing algorithm we'll use later is compatible. This is not recommended for production projects where you should use a hashing algorithm written in Javascript that matches the exact implementation as your contract and circuit.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. Tree Creation\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we have the four leaves of our tree positioned as follows\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"└─ ???\\n   ├─ ???\\n   │  ├─ 13377623690824916797327209540443066247715962236839283896963055328700043345550\\n   │  └─ 3370092681714607727019534888747304108045661953819543369463810453568040251648\\n   └─ ???\\n      ├─ 19430878135540641438890585969007029177622584902384053006985767702837167003933\\n      └─ 2288143249026782941992289125994734798520452235369536663078162770881373549221\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next, we're going to generate the Merkle tree branch by branch. Remember that Merkle trees are generated by hashing each of their leaves and branches in pairs until reaching the root.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To generate the complete tree, we'll execute the following function that hashes two leaves to generate their root. We'll do this a total of 3 times because that's what's needed to obtain the root of a tree with 4 leaves: \", _jsx(_components.code, {\n        children: \"root = hash(hash(A, B), hash(C, D))\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"hashLeaves.circom\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `pragma circom 2.0.0;\n\ninclude \"circomlib/circuits/poseidon.circom\";\n\ntemplate hashLeaves() {\n    signal input leftLeaf;\n    signal input rightLeaf;\n    signal output root;\n    component poseidonComponent;\n    poseidonComponent = Poseidon(2);\n    poseidonComponent.inputs[0] <== leftLeaf;\n    poseidonComponent.inputs[1] <== rightLeaf;\n    root <== poseidonComponent.out;\n    log(root);\n}\n\ncomponent main = hashLeaves();`,\n      language: \"cpp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here are the inputs needed to generate the first branch. Similarly, you can generate the other branch and the root.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"input.json\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `{\n    \"leftLeaf\": \"13377623690824916797327209540443066247715962236839283896963055328700043345550\",\n    \"rightLeaf\": \"3370092681714607727019534888747304108045661953819543369463810453568040251648\"\n}`,\n      language: \"json\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Similar to the previous step, with the following commands, the circuit will be compiled and the root will be printed given its two leaves.\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `circom hashLeaves.circom --r1cs --wasm --sym --c\nnode hashLeaves_js/generate_witness.js hashLeaves_js/hashLeaves.wasm input.json witness.wtns`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is how the full tree looks like:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"└─ 172702405816516791996779728912308790882282610188111072512380034048458433129\\n   ├─ 8238706810845716733547504554580992539732197518335350130391048624023669338026\\n   │  ├─ 13377623690824916797327209540443066247715962236839283896963055328700043345550\\n   │  └─ 3370092681714607727019534888747304108045661953819543369463810453568040251648\\n   └─ 11117482755699627218224304590393929490559713427701237904426421590969988571596\\n      ├─ 19430878135540641438890585969007029177622584902384053006985767702837167003933\\n      └─ 2288143249026782941992289125994734798520452235369536663078162770881373549221\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. Generate Proof of an Anonymous Vote\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To generate a vote, we need to pass the following parameters to the circuit:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"privateKey\"\n        }), \": The user's private key.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"root\"\n        }), \": The root of the tree ensures that we are operating within the correct set. Additionally, for clarity, we could add the contract and the chain where the vote will be executed. This variable will be public and accessible to the smart contract.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"proposalId\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"vote\"\n        }), \": The vote chosen by the user.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"pathElements\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"pathIndices\"\n        }), \": The minimal information needed to reconstruct the root. This includes \", _jsx(_components.code, {\n          children: \"pathElements\"\n        }), \", which are the leaf or branch nodes, and pathIndices, which show which path to take for hashing, where 0 represents nodes on the left and 1 represents nodes on the right.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"proveVote.circom\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `pragma circom 2.0.0;\n\ninclude \"circomlib/circuits/poseidon.circom\";\n\ntemplate switchPosition() {\n    signal input in[2];\n    signal input s;\n    signal output out[2];\n\n    s * (1 - s) === 0;\n    out[0] <== (in[1] - in[0])*s + in[0];\n    out[1] <== (in[0] - in[1])*s + in[1];\n}\n\ntemplate privateKeyHasher() {\n    signal input privateKey;\n    signal output publicKey;\n    component poseidonComponent;\n    poseidonComponent = Poseidon(1);\n    poseidonComponent.inputs[0] <== privateKey;\n    publicKey <== poseidonComponent.out;\n}\n\ntemplate nullifierHasher() {\n    signal input root;\n    signal input privateKey;\n    signal input proposalId;\n    signal output nullifier;\n    component poseidonComponent;\n    poseidonComponent = Poseidon(3);\n    poseidonComponent.inputs[0] <== root;\n    poseidonComponent.inputs[1] <== privateKey;\n    poseidonComponent.inputs[2] <== proposalId;\n    nullifier <== poseidonComponent.out;\n}\n\ntemplate proveVote(levels) {\n    signal input privateKey;\n    signal input root;\n    signal input proposalId;\n    signal input vote;\n    signal input pathElements[levels];\n    signal input pathIndices[levels];\n    signal output nullifier;\n\n    signal leaf;\n    component hasherComponent;\n    hasherComponent = privateKeyHasher();\n    hasherComponent.privateKey <== privateKey;\n    leaf <== hasherComponent.publicKey;\n\n    component selectors[levels];\n    component hashers[levels];\n\n    signal computedPath[levels];\n\n    for (var i = 0; i < levels; i++) {\n        selectors[i] = switchPosition();\n        selectors[i].in[0] <== i == 0 ? leaf : computedPath[i - 1];\n        selectors[i].in[1] <== pathElements[i];\n        selectors[i].s <== pathIndices[i];\n\n        hashers[i] = Poseidon(2);\n        hashers[i].inputs[0] <== selectors[i].out[0];\n        hashers[i].inputs[1] <== selectors[i].out[1];\n        computedPath[i] <== hashers[i].out;\n    }\n    root === computedPath[levels - 1];\n\n    component nullifierComponent;\n    nullifierComponent = nullifierHasher();\n    nullifierComponent.root <== root;\n    nullifierComponent.privateKey <== privateKey;\n    nullifierComponent.proposalId <== proposalId;\n    nullifier <== nullifierComponent.nullifier;\n}\n\ncomponent main {public [root, proposalId, vote]} = proveVote(2);`,\n      language: \"cpp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"input.json\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `{\n    \"privateKey\": \"111\",\n    \"root\": \"172702405816516791996779728912308790882282610188111072512380034048458433129\",\n    \"proposalId\": \"0\",\n    \"vote\": \"1\",\n    \"pathElements\": [\"3370092681714607727019534888747304108045661953819543369463810453568040251648\", \"11117482755699627218224304590393929490559713427701237904426421590969988571596\"],\n    \"pathIndices\": [\"0\",\"0\"]\n}`,\n      language: \"json\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's test if everything works correctly:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"} language=\\\"cpp\\\"/>circom proveVote.circom --r1cs --wasm --sym --c node proveVote_js/generate_witness.js proveVote_js/proveVote.wasm input.json witness.wtns\"\n      }), \"} language=\\\"bash\\\"/>\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If there were no issues, nothing should be printed in the terminal.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. Verify an on-chain vote, from Soldity\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With the following commands, we carry out the initial ceremony, also known as the trusted setup.\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `snarkjs powersoftau new bn128 12 pot12_0000.ptau -v\nsnarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=\"First contribution\" -v\nsnarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v\nsnarkjs groth16 setup proveVote.r1cs pot12_final.ptau proveVote_0000.zkey\nsnarkjs zkey contribute proveVote_0000.zkey proveVote_0001.zkey --name=\"1st Contributor Name\" -v\nsnarkjs zkey export verificationkey proveVote_0001.zkey verification_key.json`,\n      language: \"json\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next, we generate the verifier contract in Solidity.\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `snarkjs zkey export solidityverifier proveVote_0001.zkey verifier.sol`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Upon executing this command, a verifier contract will be generated in the file verifier.sol. Now deploy that contract on-chain. For example you can use foundry to deploy it on Scroll Sepolia.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create --rpc-url https://sepolia-rpc.scroll.io/ --private-key <PRIVATE_KEY> verifier.sol:Groth16Verifier\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next, deploy the following contract on-chain, which contains the logic for voting and proof verification. Pass the address of the verifier contract we just deployed as a parameter in the constructor.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"CircomVoter.sol\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ICircomVerifier {\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[4] calldata _pubSignals) external view returns (bool);\n}\n\ncontract CircomVoter {\n    ICircomVerifier circomVerifier;\n    uint public publicInput;\n\n    struct Proposal {\n        string description;\n        uint deadline;\n        uint forVotes;\n        uint againstVotes;\n    }\n\n    uint merkleRoot;\n    uint proposalCount;\n    mapping (uint proposalId => Proposal) public proposals;\n    mapping (uint nullifier => bool isNullified) public nullifiers;\n\n    constructor(uint _merkleRoot, address circomVeriferAddress) {\n        merkleRoot = _merkleRoot;\n        circomVerifier = ICircomVerifier(circomVeriferAddress);\n    }\n\n    function propose(string memory description, uint deadline) public {\n        proposals[proposalCount] = Proposal(description, deadline, 0, 0);\n        proposalCount += 1;\n    }\n\n    function castVote(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[4] calldata _pubSignals) public {\n        circomVerifier.verifyProof(_pA, _pB, _pC, _pubSignals);\n        uint nullifier = _pubSignals[0];\n        uint merkleRootPublicInput = _pubSignals[1];\n        uint proposalId = uint(_pubSignals[2]);\n        uint vote = uint(_pubSignals[3]);\n\n        require(block.timestamp < proposals[proposalId].deadline, \"Voting period is over\");\n        require(merkleRoot == merkleRootPublicInput, \"Invalid merke root\");\n        require(!nullifiers[nullifier], \"Vote already casted\");\n\n        nullifiers[nullifier] = true;\n\n        if(vote == 1)\n            proposals[proposalId].forVotes += 1;\n        else if (vote == 2)\n            proposals[proposalId].againstVotes += 1;\n    }\n}`,\n      language: \"solidity\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now deploy it on-chain. If you're using forge on Scroll Sepolia you can do it with the following command.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create --rpc-url https://sepolia-rpc.scroll.io/ --private-key <PRIVATE_KEY> --constructor-args <VERIFIER_ADDRESS> CircomVoter.sol:CircomVoter\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, create the first proposal for voting by calling the propose() function. For example, you can test by creating a vote with \\\"Should we eat pizza?\\\" as the description and with 1811799232 as the deadline, which expires in 2027.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next, let's generate a proof in the format required to verify it in Remix.\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `snarkjs groth16 prove proveVote_0001.zkey witness.wtns proof.json public.json\nsnarkjs groth16 verify verification_key.json public.json proof.json\nsnarkjs generatecall`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's pass the result from the terminal as a parameter in Remix, and we'll see how the vote was executed by accessing the data of proposal 0 through the proposals mapping.\"\n    }), \"\\n\", _jsx(\"div\", {\n      className: \"text-center\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vxtljhmmkyv2zh30i7tz.png\",\n          alt: \"Votos anónimos con Circom y Solidity\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We observe that our vote was counted without revealing who the sender was. Try to cast the same vote again, and you'll see that it won't be possible—the transaction will revert. This is because we nullified the vote so that each voter can only cast one vote.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Wrapping Up\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this guide, we combined Circom and Solidity to develop a private voting system. We began by creating private keys using Poseidon, a ZK-friendly hashing function, and then moved on to constructing a Merkle tree for managing the set of eligible voters. Following that, we generated proofs and verified them in a Solidity contract. This approach ensures the validity of all votes by verifying them on-chain, while also providing voters with anonymity guarantees by keeping their identity private through ZK proofs.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Please note that in this guide, we did everything via the CLI. UI architecture in ZK private applications is very important because we need to ensure that users' data is never exposed to the internet. We cover that in the \", _jsx(_components.a, {\n        href: \"https://www.levelup.xyz/content/privacy-interfaces-on-soldity-zk-wasm\",\n        children: \"next article\"\n      }), \", where we use ZK proofs with WASM for fast proving.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",
      "frontmatter": {},
      "scope": {}
    }
  },
  {
    "id": "privacy-interfaces-on-soldity-zk-wasm",
    "name": "Privacy Interfaces on Solidity & zk-WASM",
    "index": 4,
    "summary": "Keep users' data safe by generating proofs in the browser, on Javascript.",
    "author": "FilosofiaCodigo",
    "authorIcon": "https://avatars.githubusercontent.com/u/707484?s=96&v=4",
    "authorLink": "https://x.com/FilosofiaCodigo",
    "published": "Sep 04, 2024",
    "readTime": "15 min read",
    "labels": [
      "ZK"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    em: \"em\",\n    h2: \"h2\",\n    a: \"a\",\n    code: \"code\",\n    pre: \"pre\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components), {ContentCopy} = _components;\n  if (!ContentCopy) _missingMdxReference(\"ContentCopy\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Blockchain users need privacy in their finances, identity, social networks, and more. But web3 is transparent and public. So, how can users protect their anonymity in such an environment?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The key is to create computation proofs in a place where only the user has access, where the user's data is secure. That place is precisely the browser, before the user's data touches the internet. This is what we call client-side proving or browser proving.\"\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/zn2yfuqumjippdbdlxt4.png\",\n        alt: \"zk private inputs diagram\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"In order to keep the parameters private, they should never get out of the browser\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's get to know, with a practical and simple example, how to create interfaces that make use of zk-wasm, the technology that makes this possible.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Dependencies\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For this example, we will use Circom. If you don't have it installed, you can do so with the following commands.\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\ngit clone https://github.com/iden3/circom.git\ncd circom\ncargo build --release\ncargo install --path circom\nnpm install -g snarkjs`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. Create a circuit\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We'll create a very simple example: generating a computation proof for a multiplication a*b=c while keeping a and b private. If you're interested in a more advanced example with a real use case, visit my \", _jsx(_components.a, {\n        href: \"https://www.levelup.xyz/content/private-smart-contracts-with-solidity-and-circom\",\n        children: \"my previous article\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Circom allows us to create circuits that generate execution proofs while obfuscating the parameters.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Start by creating the following circuit:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"myCircuit.circom\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `pragma circom 2.0.0;\n\ntemplate Multiplier() {\n  signal input a;\n  signal input b;\n  signal output c;\n  c <== a*b;\n}\n\ncomponent main = Multiplier();`,\n      language: \"cpp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now compile it and generate the artifacts that we will use later.\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `circom myCircuit.circom --r1cs --wasm --sym\nsnarkjs powersoftau new bn128 12 pot12_0000.ptau -v\nsnarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=\"First contribution\" -v\nsnarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v\nsnarkjs groth16 setup myCircuit.r1cs pot12_final.ptau myCircuit_0000.zkey\nsnarkjs zkey contribute myCircuit_0000.zkey myCircuit_0001.zkey --name=\"1st Contributor Name\" -v\nsnarkjs zkey export verificationkey myCircuit_0001.zkey verification_key.json`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. Deploy the contracts\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The following command will generate a verifier contract in the verifier.sol file. Deploy it on a blockchain of your choice. This contract contains the verifyProof() function, which takes a computation proof made with our circuit as a parameter and returns true if the proof is correct.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example you can deploy it on Scroll Sepolia by using Foundry.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create --rpc-url https://sepolia-rpc.scroll.io/ --private-key <PRIVATE_KEY> verifier.sol:Groth16Verifier\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note: This contract is compatible with L1 EVMs, optimistic L2s, but in terms of ZK L2s, it is currently only compatible with Scroll.\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `snarkjs zkey export solidityverifier myCircuit_0001.zkey verifier.sol`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now deploy the following custom logic contract, passing the address of the verifier contract we deployed earlier as a constructor parameter. In this contract, you can add any desired logic in Solidity, such as vote counting in a voting system or the reception or sending of ERC20 tokens in an anonymous DeFi system. In this example, we will only store the result of the multiplication we did in our circuit.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"CircomCustomLogic.sol\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ICircomVerifier {\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[1] calldata _pubSignals) external view returns (bool);\n}\n\ncontract CircomCustomLogic {\n    ICircomVerifier circomVerifier;\n    uint public publicInput;\n\n    constructor(address circomVeriferAddress) {\n        circomVerifier = ICircomVerifier(circomVeriferAddress);\n    }\n\n    function sendProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[1] calldata _pubSignals) public {\n        // ZK verification\n        circomVerifier.verifyProof(_pA, _pB, _pC, _pubSignals);\n\n        // Your custom logic\n        publicInput = _pubSignals[0];\n    }\n}`,\n      language: \"solidity\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now deploy it on-chain. If you're using forge on Scroll Sepolia you can do it with the following command.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create --rpc-url https://sepolia-rpc.scroll.io/ --private-key <PRIVATE_KEY> --constructor-args <VERIFIER_ADDRESS> CircomCustomLogic.sol:CircomCustomLogic\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. Build a frontend\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now create this file structure:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"js/\\n  blockchain_stuff.js\\n  snarkjs.min.js\\njson_abi/\\n  MyContract.json\\nzk_artifacts/\\n  myCircuit_final.zkey\\n  myCircuit.wasm\\n  verification_key.json\\nindex.html\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"js/snarkjs.min.js\"\n        }), \": Download \", _jsx(_components.a, {\n          href: \"https://github.com/iden3/snarkjs/releases/tag/v0.7.4\",\n          children: \"snarkjs-0.7.4.zip\"\n        }), \", which contains the \", _jsx(_components.code, {\n          children: \"snarkjs.min.js\"\n        }), \" library under the \", _jsx(_components.code, {\n          children: \"build/\"\n        }), \" directory.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"json_abi/MyContract.json\"\n        }), \": the \", _jsx(_components.code, {\n          children: \"CircomCustomLogic\"\n        }), \" contract ABI we just launched, for example on Remix, you can get it by clicking the \\\"ABI\\\" button on the compiler tab.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"zk_artifacts\"\n        }), \": put in this folder the files we generated previously. Not: Change the \", _jsx(_components.code, {\n          children: \"myCircuit_0002.zkey\"\n        }), \" name for \", _jsx(_components.code, {\n          children: \"myCircuit_final.zkey\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"index.html\"\n        }), \" y \", _jsx(_components.code, {\n          children: \"js/blockchain_stuff.js\"\n        }), \" are content is detailed below.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The HTML file below describes the graphical interface where we will input the numbers to be multiplied. In a production environment, I would recommend using a frontend framework like React, Vue, or Angular. This example is for educational purposes.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"index.html\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n</head>\n<body>\n  <input id=\"connect_button\" type=\"button\" value=\"Connect\" onclick=\"connectWallet()\" style=\"display: none\"></input>\n  <p id=\"account_address\" style=\"display: none\"></p>\n  <p id=\"web3_message\"></p>\n  <p id=\"contract_state\"></p>\n  <input type=\"input\"  value=\"\" id=\"a\"></input>\n  <input type=\"input\"  value=\"\" id=\"b\"></input>\n  <input type=\"button\" value=\"Send Proof\" onclick=\"_sendProof()\"></input>\n  <br>\n  <script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/web3/1.3.5/web3.min.js\"></script>\n  <script type=\"text/javascript\" src=\"js/blockchain_stuff.js\"></script>\n  <script type=\"text/javascript\" src=\"js/snarkjs.min.js\"></script>\n</body>\n</html>\n\n<script>\n  function _sendProof()\n  {\n    a = document.getElementById(\"a\").value\n    b = document.getElementById(\"b\").value\n    sendProof(a, b)\n  }\n</script>`,\n      language: \"html\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Our JavaScript file contains both the logic for generating zk proofs using the snark.js library and the blockchain logic using the web3.js library. In a production environment, I would recommend using TypeScript instead of plain JavaScript; this example is for educational purposes.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"js/blockchain_stuff.js\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `const NETWORK_ID = 534351\n\nconst MY_CONTRACT_ADDRESS = \"0xFdAFc996a60bC5fEB307AAF81b1eD0A34a954F06\"\nconst MY_CONTRACT_ABI_PATH = \"./json_abi/MyContract.json\"\nvar my_contract\n\nvar accounts\nvar web3\n\nfunction metamaskReloadCallback() {\n  window.ethereum.on('accountsChanged', (accounts) => {\n    document.getElementById(\"web3_message\").textContent=\"Se cambió el account, refrescando...\";\n    window.location.reload()\n  })\n  window.ethereum.on('networkChanged', (accounts) => {\n    document.getElementById(\"web3_message\").textContent=\"Se el network, refrescando...\";\n    window.location.reload()\n  })\n}\n\nconst getWeb3 = async () => {\n  return new Promise((resolve, reject) => {\n    if(document.readyState==\"complete\")\n    {\n      if (window.ethereum) {\n        const web3 = new Web3(window.ethereum)\n        window.location.reload()\n        resolve(web3)\n      } else {\n        reject(\"must install MetaMask\")\n        document.getElementById(\"web3_message\").textContent=\"Error: Porfavor conéctate a Metamask\";\n      }\n    }else\n    {\n      window.addEventListener(\"load\", async () => {\n        if (window.ethereum) {\n          const web3 = new Web3(window.ethereum)\n          resolve(web3)\n        } else {\n          reject(\"must install MetaMask\")\n          document.getElementById(\"web3_message\").textContent=\"Error: Please install Metamask\";\n        }\n      });\n    }\n  });\n};\n\nconst getContract = async (web3, address, abi_path) => {\n  const response = await fetch(abi_path);\n  const data = await response.json();\n\n  const netId = await web3.eth.net.getId();\n  contract = new web3.eth.Contract(\n    data,\n    address\n    );\n  return contract\n}\n\nasync function loadDapp() {\n  metamaskReloadCallback()\n  document.getElementById(\"web3_message\").textContent=\"Please connect to Metamask\"\n  var awaitWeb3 = async function () {\n    web3 = await getWeb3()\n    web3.eth.net.getId((err, netId) => {\n      if (netId == NETWORK_ID) {\n        var awaitContract = async function () {\n          my_contract = await getContract(web3, MY_CONTRACT_ADDRESS, MY_CONTRACT_ABI_PATH)\n          document.getElementById(\"web3_message\").textContent=\"You are connected to Metamask\"\n          onContractInitCallback()\n          web3.eth.getAccounts(function(err, _accounts){\n            accounts = _accounts\n            if (err != null)\n            {\n              console.error(\"An error occurred: \"+err)\n            } else if (accounts.length > 0)\n            {\n              onWalletConnectedCallback()\n              document.getElementById(\"account_address\").style.display = \"block\"\n            } else\n            {\n              document.getElementById(\"connect_button\").style.display = \"block\"\n            }\n          });\n        };\n        awaitContract();\n      } else {\n        document.getElementById(\"web3_message\").textContent=\"Please connect to Scroll Testnet\";\n      }\n    });\n  };\n  awaitWeb3();\n}\n\nasync function connectWallet() {\n  await window.ethereum.request({ method: \"eth_requestAccounts\" })\n  accounts = await web3.eth.getAccounts()\n  onWalletConnectedCallback()\n}\n\nloadDapp()\n\nconst onContractInitCallback = async () => {\n  var publicInput = await my_contract.methods.publicInput().call()\n  var contract_state = \"Public input: \" + publicInput\n  document.getElementById(\"contract_state\").textContent = contract_state;\n}\n\nconst onWalletConnectedCallback = async () => {\n}\n\n\n//// Functions ////\n\nconst sendProof = async (a, b) => {\n  document.getElementById(\"web3_message\").textContent=\"Generating proof...\";\n\n  const { proof, publicSignals } = await snarkjs.groth16.fullProve( { a: a, b: b}, \"../zk_artifacts/myCircuit.wasm\", \"../zk_artifacts/myCircuit_final.zkey\");\n\n  const vkey = await fetch(\"../zk_artifacts/verification_key.json\").then( function(res) {\n    return res.json();\n  });\n\n  const res = await snarkjs.groth16.verify(vkey, publicSignals, proof);\n\n  pA = proof.pi_a\n  pA.pop()\n  pB = proof.pi_b\n  pB.pop()\n  pC = proof.pi_c\n  pC.pop()\n\n  document.getElementById(\"web3_message\").textContent=\"Proof generated please confirm transaction.\";\n\n  const result = await my_contract.methods.sendProof(pA, pB, pC, publicSignals)\n  .send({ from: accounts[0], gas: 0, value: 0 })\n  .on('transactionHash', function(hash){\n    document.getElementById(\"web3_message\").textContent=\"Executing...\";\n  })\n  .on('receipt', function(receipt){\n    document.getElementById(\"web3_message\").textContent=\"Success.\";    })\n  .catch((revertReason) => {\n    console.log(\"ERROR! Transaction reverted: \" + revertReason.receipt.transactionHash)\n  });\n}`,\n      language: \"js\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. Try the app\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Before testing, you need to adjust the variables NETWORK_ID and MY_CONTRACT_ADDRESS in js/blockchain_stuff.js. NETWORK_ID is the unique identifier of the chain you are using. In this example, I'm using 534351, which represents the Scroll Sepolia Testnet. If you wish to use another chain, I recommend finding the identifier on \", _jsx(_components.a, {\n        href: \"https://chainlist.org/\",\n        children: \"chainlist\"\n      }), \". Also, place the address of the CircomCustomLogic contract you just deployed into the MY_CONTRACT_ADDRESS variable.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now you're ready to test the application on any web server. I typically use lite-server for development. Here's how you can install it and start a server, just make sure you are in the project folder:\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `npm install -g lite-server #para instalar\nlite-server #para levantar el servidor`,\n      language: \"bash\"\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a24eo00jc3rbfxe8bgpx.png\",\n        alt: \"ejemplo de circuito multiplicador zk\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Once everything is ready this is how your app should look like\"\n        })\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",
      "frontmatter": {},
      "scope": {}
    }
  },
  {
    "id": "huracan",
    "name": "🌀Huracan",
    "index": 5,
    "summary": "Learn ZK by Deploying a Battle Tested Project.",
    "author": "FilosofiaCodigo",
    "authorIcon": "https://avatars.githubusercontent.com/u/707484?s=96&v=4",
    "authorLink": "https://x.com/FilosofiaCodigo",
    "published": "Sep 04, 2024",
    "readTime": "15 min read",
    "labels": [
      "ZK",
      "DeFi"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\n/*\n## Table of Contents\n\n1. [How Huracán Works](#1-how-huracán-works)\n1. [The Circuit](#2-the-circuit)\n1. [The Contracts](#3-the-contracts)\n1. [The Frontend](#4-the-frontend)\n1. [The Relayer](#5-the-relayer)\n1. [How to Take Huracán to Production](#6-how-to-take-huracán-to-production)\n1. [Ideas for Further Exploration](#7-ideas-for-further-exploration)\n*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    em: \"em\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    code: \"code\",\n    pre: \"pre\",\n    h3: \"h3\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {ContentCopy} = _components;\n  if (!ContentCopy) _missingMdxReference(\"ContentCopy\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Learning about ZK today is not an easy task. It's a new technology with limited documentation. Huracan was born out of my own need to learn about ZK in a practical way, geared towards developers and engineers.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Huracan is a fully functional project capable of performing private transactions on Ethereum and EVM blockchains. It's based on battle tested privacy projects but includes only the minimal code to simplify the learning process. We will cover how this technology can be adapted to new use cases and future regulations. Additionally, at the end of the article, I share what is needed to take this project from testnet to real production use.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"By the end of this guide, you'll be able to research other projects of the same nature and understand how they are built.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Prefer to see the complete code? \", _jsx(_components.a, {\n        href: \"https://github.com/Turupawn/Huracan\",\n        children: \"Head to Github\"\n      }), \" to find all the code mentioned in this guide.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.em, {\n        children: \"How Huracán is Built:\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Circom circuits\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Poseidon hash\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Deposit and withdrawal logic in Solidity\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Merkle tree generation in JS and Solidity, verification in Circom\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"HTML and JS vanilla Frontend\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"web3.js for web3 interaction and snarkjs for browser proving (zk-WASM)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Relayer with ethers.js 6 and Express to preserve user anonymity\"\n      }), \"\\n\"]\n    }), \"\\n\", \"\\n\", _jsx(_components.h2, {\n      children: \"1. How Huracán Works\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Huracán is a DeFi tool that protects the identity of its users using a technique known as \", _jsx(_components.em, {\n        children: \"anonymous inclusion proofs\"\n      }), \" to perform what is commonly called a \", _jsx(_components.em, {\n        children: \"mixer\"\n      }), \". This system can prove that a user has deposited ether into a contract without revealing which one he is.\"]\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/if5yhd2ef1vwr0bujxkz.png\",\n        alt: \"Depositing in Huracán\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Each user who deposits Ether into Huracán is added as a leaf in a Merkle tree within the contract\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To achieve this, we need a smart contract where funds are deposited, which will generate a Merkle tree where each leaf represents a depositor. Additionally, we will need a circuit that generates inclusion proofs to keep the user anonymous when withdrawing funds. We also need a relayer that will execute the transaction on behalf of the anonymous user to protect their privacy.\"\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/igrb94o5cidddo3c8s5z.png\",\n        alt: \"Withdrawing from Huracán\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Users can later withdraw their funds by proving they are part of the Merkle tree without revealing which leaf belongs to them\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Below is the code, a brief explanation, and the supporting materials necessary to build and launch your own privacy-focused project.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. The Circuit\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.em, {\n        children: [\"Supporting Material: \", _jsx(_components.a, {\n          href: \"https://www.levelup.xyz/content/private-smart-contracts-with-solidity-and-circom\",\n          children: \"Private Smart Contracts with Solidity and Circom\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The circuit is responsible for proving that you are part of the Merkle tree, meaning you are one of the depositors without revealing which one you are since you keep the parameters private while generating an inclusion proof that can be verified by a smart contract. Which parameters are kept private? During the deposit, we hash a private key and a nullifier to create a new leaf in the tree. The private key is a private parameter that will later serve to prove that you are the owner of that leaf. The nullifier is another parameter whose hash will be passed to the Solidity contract when redeeming funds, preventing a user from withdrawing funds twice in a row (double spend). The rest of the private parameters help the circuit reconstruct the tree and verify that you are part of it.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We start by installing the \", _jsx(_components.code, {\n        children: \"circomlib\"\n      }), \" library, which contains the Poseidon circuits we will be using in this tutorial.\"]\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `git clone https://github.com/iden3/circomlib.git`,\n      language: \"bash\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now we create our \", _jsx(_components.code, {\n        children: \"proveWithdrawal\"\n      }), \" circuit that proves we have deposited in the contract without revealing who we are.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"proveWithdrawal.circom\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `pragma circom 2.0.0;\n\ninclude \"circomlib/circuits/poseidon.circom\";\n\ntemplate switchPosition() {\n    signal input in[2];\n    signal input s;\n    signal output out[2];\n\n    s * (1 - s) === 0;\n    out[0] <== (in[1] - in[0])*s + in[0];\n    out[1] <== (in[0] - in[1])*s + in[1];\n}\n\ntemplate commitmentHasher() {\n    signal input privateKey;\n    signal input nullifier;\n    signal output commitment;\n    signal output nullifierHash;\n    component commitmentHashComponent;\n    commitmentHashComponent = Poseidon(2);\n    commitmentHashComponent.inputs[0] <== privateKey;\n    commitmentHashComponent.inputs[1] <== nullifier;\n    commitment <== commitmentHashComponent.out;\n    component nullifierHashComponent;\n    nullifierHashComponent = Poseidon(1);\n    nullifierHashComponent.inputs[0] <== nullifier;\n    nullifierHash <== nullifierHashComponent.out;\n}\n\ntemplate proveWithdrawal(levels) {\n    signal input root;\n    signal input recipient;\n    signal input privateKey;\n    signal input nullifier;\n    signal input pathElements[levels];\n    signal input pathIndices[levels];\n    signal output nullifierHash;\n\n    signal leaf;\n    component commitmentHasherComponent;\n    commitmentHasherComponent = commitmentHasher();\n    commitmentHasherComponent.privateKey <== privateKey;\n    commitmentHasherComponent.nullifier <== nullifier;\n    leaf <== commitmentHasherComponent.commitment;\n    nullifierHash <== commitmentHasherComponent.nullifierHash;\n\n    component selectors[levels];\n    component hashers[levels];\n\n    signal computedPath[levels];\n\n    for (var i = 0; i < levels; i++) {\n        selectors[i] = switchPosition();\n        selectors[i].in[0] <== i == 0 ? leaf : computedPath[i - 1];\n        selectors[i].in[1] <== pathElements[i];\n        selectors[i].s <== pathIndices[i];\n\n        hashers[i] = Poseidon(2);\n        hashers[i].inputs[0] <== selectors[i].out[0];\n        hashers[i].inputs[1] <== selectors[i].out[1];\n        computedPath[i] <== hashers[i].out;\n    }\n    root === computedPath[levels - 1];\n}\n\ncomponent main {public [root, recipient]} = proveWithdrawal(2);`,\n      language: \"cpp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To compile the circuit, we need to have both Circom and snarkjs installed. If you don't have them installed, follow the Circom installation guide.\"\n    }), \"\\n\", _jsxs(\"details\", {\n      children: [_jsx(\"summary\", {\n        children: \"Circom installation guide\"\n      }), _jsx(_components.p, {\n        children: \"Run the following commands to install circom and snarkjs.\"\n      }), _jsx(ContentCopy, {\n        code: `curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\ngit clone https://github.com/iden3/circom.git\ncd circom\ncargo build --release\ncargo install --path circom\nnpm install -g snarkjs`,\n        language: \"bash\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Generate the trusted setup and zk artifacts we will need later on on the frontend.\"\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `circom proveWithdrawal.circom --r1cs --wasm --sym\nsnarkjs powersoftau new bn128 12 pot12_0000.ptau -v\nsnarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=\"First contribution\" -v\nsnarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v\nsnarkjs groth16 setup proveWithdrawal.r1cs pot12_final.ptau proveWithdrawal_0000.zkey\nsnarkjs zkey contribute proveWithdrawal_0000.zkey proveWithdrawal_0001.zkey --name=\"1st Contributor Name\" -v\nsnarkjs zkey export verificationkey proveWithdrawal_0001.zkey verification_key.json`,\n      language: \"bash\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We can now generate the \", _jsx(_components.code, {\n        children: \"verifier.sol\"\n      }), \" contract.\"]\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `snarkjs zkey export solidityverifier proveWithdrawal_0001.zkey verifier.sol`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. The Contracts\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The contracts serve as a guarantee that everything was run correctly. They allow us to keep track of how much has been deposited and verify that the proofs are valid in order to release the funds. It’s important to note that everything happening in the smart contracts is public; this is the part of our system that is not anonymous.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We will use three contracts. The first is the verifier contract that we just generated in the \", _jsx(_components.code, {\n        children: \"verifier.sol\"\n      }), \" file, so go ahead and deploy it now. For example you can use foundry to deploy it on Scroll Sepolia.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create --rpc-url https://sepolia-rpc.scroll.io/ --private-key <PRIVATE_KEY> verifier.sol:Groth16Verifier\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The second contract is the Poseidon contract. If you are on Scroll Sepolia, you can simply use the one I've already deployed at \", _jsx(_components.code, {\n        children: \"0x52f28FEC91a076aCc395A8c730dCa6440B6D9519\"\n      }), \". If you want to use another blockchain, expand and follow the steps:\"]\n    }), \"\\n\", _jsxs(\"details\", {\n      children: [_jsx(\"summary\", {\n        children: \"Deploy the Poseidon contract\"\n      }), _jsxs(_components.p, {\n        children: [\"The version of Poseidon we use in our circuit and contract must be exactly compatible. Therefore, we use the version in \", _jsx(_components.code, {\n          children: \"circomlibjs\"\n        }), \" as shown. Just make sure to insert your private key and RPC URL in place of \", _jsx(_components.code, {\n          children: \"YOURPRIVATEKEY\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"YOURRPCURL\"\n        }), \".\"]\n      }), _jsx(ContentCopy, {\n        code: `git clone https://github.com/iden3/circomlibjs.git\ncd circomlibjs\nnpm install\ncd ..\nnode --input-type=module --eval \"import { writeFileSync } from 'fs'; import('./circomlibjs/src/poseidon_gencontract.js').then(({ createCode }) => { const output = createCode(2); writeFileSync('poseidonBytecode', output); })\"\ncast send --rpc-url TUURLRPC --private-key TULLAVEPRIVADA --create $(cat bytecode)`,\n        language: \"bash\"\n      }), _jsxs(_components.p, {\n        children: [\"On Scroll, I added \", _jsx(_components.code, {\n          children: \"--legacy --gas-price 5000000000\"\n        }), \", probably when you see this video you won't need to add it. In any case you shouldn't need this in other chains. Regardless, this is the command just as I sent it.\"]\n      }), _jsx(ContentCopy, {\n        code: `cast send --rpc-url TUURLRPC --legacy --gas-price 5000000000 --private-key TULLAVEPRIVADA --create $(cat bytecode)`,\n        language: \"bash\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now deploy the \", _jsx(_components.code, {\n        children: \"Huracan\"\n      }), \" contract by passing the verifier and poseidon addresses as parameters.\"]\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IPoseidon {\n    function poseidon(uint[2] memory inputs) external returns(uint[1] memory output);\n}\n\ninterface ICircomVerifier {\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[3] calldata _pubSignals) external view returns (bool);\n}\n\ncontract Huracan {\n    ICircomVerifier circomVerifier;\n    uint nextIndex;\n    uint public constant LEVELS = 2;\n    uint public constant MAX_SIZE = 4;\n    uint public NOTE_VALUE = 0.001 ether;\n    uint[] public filledSubtrees = new uint[](LEVELS);\n    uint[] public emptySubtrees = new uint[](LEVELS);\n    address POSEIDON_ADDRESS;\n    uint public root;\n\n    mapping(uint => uint) public commitments;\n    mapping(uint => bool) public nullifiers;\n\n    event Deposit(uint index, uint commitment);\n\n    constructor(address poseidonAddress, address circomVeriferAddress) {\n        POSEIDON_ADDRESS = poseidonAddress;\n        circomVerifier = ICircomVerifier(circomVeriferAddress);\n\n        for (uint32 i = 1; i < LEVELS; i++) {\n            emptySubtrees[i] = IPoseidon(POSEIDON_ADDRESS).poseidon([\n                emptySubtrees[i-1],\n                0\n            ])[0];\n        }\n    }\n\n    function deposit(uint commitment) public payable {\n        require(msg.value == NOTE_VALUE, \"Invalid value sent\");\n        require(nextIndex != MAX_SIZE, \"Merkle tree is full. No more leaves can be added\");\n        uint currentIndex = nextIndex;\n        uint currentLevelHash = commitment;\n        uint left;\n        uint right;\n\n        for (uint32 i = 0; i < LEVELS; i++) {\n            if (currentIndex % 2 == 0) {\n                left = currentLevelHash;\n                right = emptySubtrees[i];\n                filledSubtrees[i] = currentLevelHash;\n            } else {\n                left = filledSubtrees[i];\n                right = currentLevelHash;\n            }\n            currentLevelHash = IPoseidon(POSEIDON_ADDRESS).poseidon([left, right])[0];\n            currentIndex /= 2;\n        }\n\n        root = currentLevelHash;\n        emit Deposit(nextIndex, commitment);\n        commitments[nextIndex] = commitment;\n        nextIndex = nextIndex + 1;\n    }\n\n    function withdraw(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[3] calldata _pubSignals) public {\n        circomVerifier.verifyProof(_pA, _pB, _pC, _pubSignals);\n        uint nullifierHash = _pubSignals[0];\n        uint rootPublicInput = _pubSignals[1];\n        address recipient = address(uint160(_pubSignals[2]));\n\n        require(root == rootPublicInput, \"Invalid merke root\");\n        require(!nullifiers[nullifierHash], \"Vote already casted\");\n\n        nullifiers[nullifierHash] = true;\n\n        (bool sent, bytes memory data) = recipient.call{value: NOTE_VALUE}(\"\");\n        require(sent, \"Failed to send Ether\");\n        data;\n    }\n}`,\n      language: \"cpp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now deploy it on-chain. If you're using forge on Scroll Sepolia you can do it with the following command.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create --rpc-url https://sepolia-rpc.scroll.io/ --private-key <PRIVATE_KEY> --constructor-args <VERIFIER_ADDRESS> Huracan.sol:Huracan\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. The Frontend\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.em, {\n        children: [\"Supporting Material: \", _jsx(_components.a, {\n          href: \"https://www.levelup.xyz/content/privacy-interfaces-on-soldity-zk-wasm\",\n          children: \"Privacy Interfaces with Solidity and zk-WASM\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The frontend is the graphical interface we will be interacting with. In this demonstration, we will be using HTML and vanilla JS so that developers can adapt it to any frontend framework they are using. Something very important is that the frontend must be capable of producing zk proofs without leaking private information over the internet. This is why zk-WASM is crucial, as it allows us to efficiently generate proofs directly in our browser.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, create the following file structure:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"js/\\n  blockchain_stuff.js\\n  snarkjs.min.js\\njson_abi/\\n  Huracan.json\\n  Poseidon.json\\nzk_artifacts/\\n  proveWithdrawal_final.zkey\\n  proveWithdrawal.wasm\\nindex.html\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"js/snarkjs.min.js\"\n        }), \": Download \", _jsx(_components.a, {\n          href: \"https://github.com/iden3/snarkjs/releases/tag/v0.7.4\",\n          children: \"snarkjs-0.7.4.zip\"\n        }), \", which contains the \", _jsx(_components.code, {\n          children: \"snarkjs.min.js\"\n        }), \" library under the \", _jsx(_components.code, {\n          children: \"build/\"\n        }), \" directory.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"json_abi/Huracan.json\"\n        }), \": The ABI of the CircomCustomLogic contract we just deployed (e.g., in Remix). You can obtain it by clicking the \\\"ABI\\\" button in the compilation tab.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"json_abi/Poseidon.json\"\n        }), \": Use \", _jsx(_components.a, {\n          href: \"https://gist.github.com/Turupawn/b89999eb8b00d7507908d6fbf6aa7f0b\",\n          children: \"this file\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"zk_artifacts\"\n        }), \": Place the previously generated artifacts in this folder. Note: Rename \", _jsx(_components.code, {\n          children: \"proveWithdrawal_0001.zkey\"\n        }), \" to \", _jsx(_components.code, {\n          children: \"proveWithdrawal_final.zkey\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"index.html\"\n        }), \", \", _jsx(_components.code, {\n          children: \"js/blockchain_stuff.js\"\n        }), \", and \", _jsx(_components.code, {\n          children: \"js/zk_stuff.js\"\n        }), \": These will be detailed below.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The HTML file contains the interface necessary for users to interact with Huracán.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"index.html\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n</head>\n<body>\n  <input id=\"connect_button\" type=\"button\" value=\"Connect\" onclick=\"connectWallet()\" style=\"display: none\"></input>\n  <p id=\"account_address\" style=\"display: none\"></p>\n  <p id=\"web3_message\"></p>\n  <p id=\"contract_state\"></p>\n  <input type=\"input\"  value=\"\" id=\"depositPrivateKey\" placeholder=\"private key\"></input>\n  <input type=\"input\"  value=\"\" id=\"depositNullifier\" placeholder=\"nullifier\"></input>\n  <input type=\"button\" value=\"Deposit\" onclick=\"_deposit()\"></input>\n  <br>\n  <input type=\"input\"  value=\"\" id=\"withdrawPrivateKey\" placeholder=\"private key\"></input>\n  <input type=\"input\"  value=\"\" id=\"withdrawNullifier\" placeholder=\"nullifier\"></input>\n  <input type=\"input\"  value=\"\" id=\"withdrawRecipient\" placeholder=\"recipient\"></input>\n  <input type=\"button\" value=\"Withdraw\" onclick=\"_withdraw()\"></input>\n  <br>\n  <script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/web3/1.3.5/web3.min.js\"></script>\n  <script type=\"text/javascript\" src=\"js/zk_stuff.js\"></script>\n  <script type=\"text/javascript\" src=\"js/blockchain_stuff.js\"></script>\n  <script type=\"text/javascript\" src=\"js/snarkjs.min.js\"></script>\n</body>\n</html>\n\n<script>\n  function _deposit()\n  {\n    depositPrivateKey = document.getElementById(\"depositPrivateKey\").value\n    depositNullifier = document.getElementById(\"depositNullifier\").value\n    deposit(depositPrivateKey, depositNullifier)\n  }\n\n  function _withdraw()\n  {\n    withdrawPrivateKey = document.getElementById(\"withdrawPrivateKey\").value\n    withdrawNullifier = document.getElementById(\"withdrawNullifier\").value\n    withdrawRecipient = document.getElementById(\"withdrawRecipient\").value\n    withdraw(withdrawPrivateKey, withdrawNullifier, withdrawRecipient)\n  }\n</script>`,\n      language: \"html\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Al logic related to web3 is placed in the following file. This includes browser and wallet connection, state read and contract function calls.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"js/blockchain_stuff.js\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `const NETWORK_ID = 534351\n\nconst HURACAN_ADDRESS = \"0x8BD32BDC921f5239c0f5d9eaf093B49A67C3b9d0\"\nconst HURACAN_ABI_PATH = \"./json_abi/Huracan.json\"\n\nconst POSEIDON_ADDRESS = \"0x52f28FEC91a076aCc395A8c730dCa6440B6D9519\"\nconst POSEIDON_ABI_PATH = \"./json_abi/Poseidon.json\"\n\nconst RELAYER_URL = \"http://localhost:8080\"\n\nvar huracanContract\nvar poseidonContract\n\nvar accounts\nvar web3\nlet leaves\n\nfunction metamaskReloadCallback() {\n  window.ethereum.on('accountsChanged', (accounts) => {\n    document.getElementById(\"web3_message\").textContent=\"Se cambió el account, refrescando...\";\n    window.location.reload()\n  })\n  window.ethereum.on('networkChanged', (accounts) => {\n    document.getElementById(\"web3_message\").textContent=\"Se el network, refrescando...\";\n    window.location.reload()\n  })\n}\n\nconst getWeb3 = async () => {\n  return new Promise((resolve, reject) => {\n    if(document.readyState==\"complete\")\n    {\n      if (window.ethereum) {\n        const web3 = new Web3(window.ethereum)\n        window.location.reload()\n        resolve(web3)\n      } else {\n        reject(\"must install MetaMask\")\n        document.getElementById(\"web3_message\").textContent=\"Error: Porfavor conéctate a Metamask\";\n      }\n    }else\n    {\n      window.addEventListener(\"load\", async () => {\n        if (window.ethereum) {\n          const web3 = new Web3(window.ethereum)\n          resolve(web3)\n        } else {\n          reject(\"must install MetaMask\")\n          document.getElementById(\"web3_message\").textContent=\"Error: Please install Metamask\";\n        }\n      });\n    }\n  });\n};\n\nconst getContract = async (web3, address, abi_path) => {\n  const response = await fetch(abi_path);\n  const data = await response.json();\n\n  const netId = await web3.eth.net.getId();\n  contract = new web3.eth.Contract(\n    data,\n    address\n    );\n  return contract\n}\n\nasync function loadDapp() {\n  metamaskReloadCallback()\n  document.getElementById(\"web3_message\").textContent=\"Please connect to Metamask\"\n  var awaitWeb3 = async function () {\n    web3 = await getWeb3()\n    web3.eth.net.getId((err, netId) => {\n      if (netId == NETWORK_ID) {\n        var awaitContract = async function () {\n          huracanContract = await getContract(web3, HURACAN_ADDRESS, HURACAN_ABI_PATH)\n          poseidonContract = await getContract(web3, POSEIDON_ADDRESS, POSEIDON_ABI_PATH)\n          document.getElementById(\"web3_message\").textContent=\"You are connected to Metamask\"\n          onContractInitCallback()\n          web3.eth.getAccounts(function(err, _accounts){\n            accounts = _accounts\n            if (err != null)\n            {\n              console.error(\"An error occurred: \"+err)\n            } else if (accounts.length > 0)\n            {\n              onWalletConnectedCallback()\n              document.getElementById(\"account_address\").style.display = \"block\"\n            } else\n            {\n              document.getElementById(\"connect_button\").style.display = \"block\"\n            }\n          });\n        };\n        awaitContract();\n      } else {\n        document.getElementById(\"web3_message\").textContent=\"Please connect to Goerli\";\n      }\n    });\n  };\n  awaitWeb3();\n}\n\nasync function connectWallet() {\n  await window.ethereum.request({ method: \"eth_requestAccounts\" })\n  accounts = await web3.eth.getAccounts()\n  onWalletConnectedCallback()\n}\n\nloadDapp()\n\nconst onContractInitCallback = async () => {\n  document.getElementById(\"web3_message\").textContent=\"Reading merkle tree data...\";\n  leaves = []\n  let i =0\n  let maxSize = await huracanContract.methods.MAX_SIZE().call()\n  for(let i=0; i<maxSize; i++)\n  {\n    leaves.push(await huracanContract.methods.commitments(i).call())\n  }\n  document.getElementById(\"web3_message\").textContent=\"All ready!\";\n}\n\nconst onWalletConnectedCallback = async () => {\n}\n\n\n//// Functions ////\n\nconst deposit = async (depositPrivateKey, depositNullifier) => {\n  let commitment = await poseidonContract.methods.poseidon([depositPrivateKey,depositNullifier]).call()\n\n  let value = await huracanContract.methods.NOTE_VALUE().call()\n\n  document.getElementById(\"web3_message\").textContent=\"Please confirm transaction.\";\n\n  const result = await huracanContract.methods.deposit(commitment)\n    .send({ from: accounts[0], gas: 0, value: value })\n    .on('transactionHash', function(hash){\n      document.getElementById(\"web3_message\").textContent=\"Executing...\";\n    })\n  .on('receipt', function(receipt){\n    document.getElementById(\"web3_message\").textContent=\"Success.\";    })\n  .catch((revertReason) => {\n    console.log(\"ERROR! Transaction reverted: \" + revertReason.receipt.transactionHash)\n  });\n}\n\nconst withdraw = async (privateKey, nullifier, recipient) => {\n  document.getElementById(\"web3_message\").textContent=\"Generating proof...\";\n\n  let commitment = await poseidonContract.methods.poseidon([privateKey,nullifier]).call()\n\n  let index = null\n  for(let i=0; i<leaves.length;i++)\n  {\n    if(commitment == leaves[i])\n    {\n      index = i\n    }\n  }\n\n  if(index == null)\n  {\n    console.log(\"Commitment not found in merkle tree\")\n    return\n  }\n\n  let root = await huracanContract.methods.root().call()\n  let proof = await getWithdrawalProof(index, privateKey, nullifier, recipient, root)\n\n  await sendProofToRelayer(proof.pA, proof.pB, proof.pC, proof.publicSignals)\n}\n\nconst sendProofToRelayer = async (pA, pB, pC, publicSignals) => {\n  fetch(RELAYER_URL + \"/relay?pA=\" + pA + \"&pB=\" + pB + \"&pC=\" + pC + \"&publicSignals=\" + publicSignals)\n  .then(res => res.json())\n  .then(out =>\n    console.log(out))\n  .catch();\n}`,\n      language: \"js\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Finally, the file that contains all ZK logic. Capable of generating ZK proofs.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"js/zk_stuff.js\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `async function getMerklePath(leaves) {\n  if (leaves.length === 0) {\n    throw new Error('Leaves array is empty');\n  }\n\n  let layers = [leaves];\n\n  // Build the Merkle tree\n  while (layers[layers.length - 1].length > 1) {\n    const currentLayer = layers[layers.length - 1];\n    const nextLayer = [];\n\n    for (let i = 0; i < currentLayer.length; i += 2) {\n      const left = currentLayer[i];\n      const right = currentLayer[i + 1] ? currentLayer[i + 1] : left; // Handle odd number of nodes\n      nextLayer.push(await poseidonContract.methods.poseidon([left,right]).call())\n    }\n    layers.push(nextLayer);\n  }\n\n  const root = layers[layers.length - 1][0];\n\n  function getPath(leafIndex) {\n    let pathElements = [];\n    let pathIndices = [];\n    let currentIndex = leafIndex;\n\n    for (let i = 0; i < layers.length - 1; i++) {\n      const currentLayer = layers[i];\n      const isLeftNode = currentIndex % 2 === 0;\n      const siblingIndex = isLeftNode ? currentIndex + 1 : currentIndex - 1;\n\n      pathIndices.push(isLeftNode ? 0 : 1);\n      pathElements.push(siblingIndex < currentLayer.length ? currentLayer[siblingIndex] : currentLayer[currentIndex]);\n\n      currentIndex = Math.floor(currentIndex / 2);\n    }\n\n    return {\n      PathElements: pathElements,\n      PathIndices: pathIndices\n    };\n  }\n\n  // You can get the path for any leaf index by calling getPath(leafIndex)\n  return {\n    getMerklePathForLeaf: getPath,\n    root: root\n  };\n}\n\nfunction addressToUint(address) {\n  const hexString = address.replace(/^0x/, '');\n  const uint = BigInt('0x' + hexString);\n  return uint;\n}\n\nasync function getWithdrawalProof(index, privateKey, nullifier, recipient, root) {\n  let merklePath = await getMerklePath(leaves)\n  let pathElements = merklePath.getMerklePathForLeaf(index).PathElements;\n  let pathIndices = merklePath.getMerklePathForLeaf(index).PathIndices;\n  let proverParams = {\n    \"privateKey\": privateKey,\n    \"nullifier\": nullifier,\n    \"recipient\": addressToUint(recipient),\n    \"root\": root,\n    \"pathElements\": pathElements,\n    \"pathIndices\": pathIndices\n  }\n\n  const { proof, publicSignals } = await snarkjs.groth16.fullProve( \n    proverParams, \n    \"../zk_artifacts/proveWithdrawal.wasm\", \"../zk_artifacts/proveWithdrawal_final.zkey\"\n  );\n\n  let pA = proof.pi_a\n  pA.pop()\n  let pB = proof.pi_b\n  pB.pop()\n  let pC = proof.pi_c\n  pC.pop()\n\n  document.getElementById(\"web3_message\").textContent=\"Proof generated please confirm transaction.\";\n\n  return {\n    pA: pA,\n    pB: pB,\n    pC: pC,\n    publicSignals: publicSignals\n  }\n}`,\n      language: \"cpp\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"5. The Relayer\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Generating ZK anonymity proofs makes no sense if we end up posting the transaction ourselves. Doing so would compromise privacy, as everything on Ethereum is public. This is why we need a relayer, an intermediary that executes the transaction on-chain on behalf of the anonymous user.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's start by creating the backend file.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"relayer.mjs\"\n      })\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `import fs from \"fs\"\nimport cors from \"cors\"\nimport express from \"express\"\nimport { ethers } from 'ethers';\n\nconst app = express()\napp.use(cors())\n\nconst JSON_CONTRACT_PATH = \"./json_abi/Huracan.json\"\nconst CHAIN_ID = \"534351\"\nconst PORT = 8080\nvar contract\nvar provider\nvar signer\n\nconst { RPC_URL, HURACAN_ADDRESS, RELAYER_PRIVATE_KEY, RELAYER_ADDRESS } = process.env;\n\nconst loadContract = async (data) => {\n  data = JSON.parse(data);\n  contract = new ethers.Contract(HURACAN_ADDRESS, data, signer);\n}\n\nasync function initAPI() {\n  provider = new ethers.JsonRpcProvider(RPC_URL);\n  signer = new ethers.Wallet(RELAYER_PRIVATE_KEY, provider);\n\n  fs.readFile(JSON_CONTRACT_PATH, 'utf8', function (err,data) {\n    if (err) {\n      return console.log(err);\n    }\n    loadContract(data)\n  });\n\n  app.listen(PORT, () => {\n    console.log(\\`Listening to port \\${PORT}\\`)\n  })\n}\n\nasync function relayMessage(pA, pB, pC, publicSignals)\n{\n  console.log(pA)\n  console.log(pB)\n  console.log(pC)\n  console.log(publicSignals)\n  const transaction = {\n    from: RELAYER_ADDRESS,\n    to: HURACAN_ADDRESS,\n    value: '0',\n    gasPrice: \"700000000\", // 0.7 gwei\n    nonce: await provider.getTransactionCount(RELAYER_ADDRESS),\n    chainId: CHAIN_ID,\n    data: contract.interface.encodeFunctionData(\n      \"withdraw\",[pA, pB, pC, publicSignals]\n    )\n  };\n  const signedTransaction = await signer.populateTransaction(transaction);\n  const transactionResponse = await signer.sendTransaction(signedTransaction);\n  console.log('🎉 The hash of your transaction is:', transactionResponse.hash);\n}\n\napp.get('/relay', (req, res) => {\n  console.log(req)\n  var pA = req.query[\"pA\"].split(',')\n  var pBTemp = req.query[\"pB\"].split(',')\n  const pB = [\n    [pBTemp[0], pBTemp[1]],\n    [pBTemp[2], pBTemp[3]]\n  ];\n  var pC = req.query[\"pC\"].split(',')\n  var publicSignals = req.query[\"publicSignals\"].split(',')\n\n  relayMessage(pA, pB, pC, publicSignals)\n\n  res.setHeader('Content-Type', 'application/json');\n  res.send({\n    \"message\": \"the proof was relayed\"\n  })\n})\n\ninitAPI()`,\n      language: \"js\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Install the \", _jsx(_components.code, {\n        children: \"coors\"\n      }), \" library to run the relayer locally.\"]\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `npm install cors express ethers`,\n      language: \"bash\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now deploy the server by replacing \", _jsx(_components.code, {\n        children: \"TUURLRPC\"\n      }), \", \", _jsx(_components.code, {\n        children: \"TUHURACANADDRESS\"\n      }), \", \", _jsx(_components.code, {\n        children: \"TULLAVEPRIVADA\"\n      }), \", \", _jsx(_components.code, {\n        children: \"TUADDRESS\"\n      }), \" in the following command.\"]\n    }), \"\\n\", _jsx(ContentCopy, {\n      code: `RPC_URL=TUURLRPC HURACAN_ADDRESS=TUHURACANADDRESS RELAYER_PRIVATE_KEY=TULLAVEPRIVADA RELAYER_ADDRESS=TUADDRESS node relayer.mjs`,\n      language: \"bash\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You are ready to deposit and withdraw funds on Huracan from the web interface.\"\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/m0gfsc81pgjfcyt32gyu.png\",\n        alt: \"Huracan web\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Once everything is ready this is how your app should look like\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"6. How to Take Huracan to Production?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"a. Store Historical Roots On-Chain\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"By only storing the most recent root, the generated proof must use this root. This means that if someone deposits right after generating a withdrawal proof, and thus modifies the root, the proof will become invalid, and a new one will need to be generated.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Necessary Changes:\"\n      }), \" Store the entire historical record of roots on-chain, for example, using a mapping like \", _jsx(_components.code, {\n        children: \"mapping(uint id => uint root) public roots;\"\n      }), \" and use the most recent root when generating a proof. If someone makes a deposit and changes the root, there will be no problem as the verification will be done against any historically saved root using a function like \", _jsx(_components.code, {\n        children: \"isKnownRoot(uint root)\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"b. Index the Merkle Tree in an Accessible Place\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To generate an inclusion proof, we need to read the current state of the tree. Currently, we read it from the \", _jsx(_components.code, {\n        children: \"commitments\"\n      }), \" variable, but this process is slow and requires many RPC calls if the tree size is large.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Necessary Changes:\"\n      }), \" Store and index the entire tree in an accessible location. An ideal place for this might be a subgraph.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"c. Incentivize the Relayer\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It’s necessary to offer a reward to the relayer, as they cover the on-chain transaction fees.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Necessary Changes:\"\n      }), \" When generating the proof, allocate a percentage of the note to the relayer. You can do this by adding an extra parameter in the circuits, like \", _jsx(_components.code, {\n        children: \"signal input fee;\"\n      }), \", and in Solidity, send this value to \", _jsx(_components.code, {\n        children: \"msg.sender\"\n      }), \" or to the address determined by the relayer.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"d. Use Appropriate Libraries\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the web app, instead of vanilla HTML and JS, you should use a frontend framework like React, Angular, or Vue to provide a better experience for users and developers.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For the relayer, instead of Express, use a more robust backend and host it on a machine equipped to handle a high number of transactions with anti-DoS mechanisms and a suitable firewall, as the relayer’s funds used for gas are a target for hacking.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"e. Define the Size of the Merkle Tree\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This example works for 4 depositors; you’ll need to reflect changes in the circuit and contract to accommodate a larger tree.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Necessary Changes:\"\n      }), \" Start by changing \", _jsx(_components.a, {\n        href: \"https://github.com/Turupawn/Huracan/blob/master/circuits/proveWithdrawal.circom#L67\",\n        children: \"the number of levels in the circuit\"\n      }), \"; it is currently set to 2, which is enough for a tree with 4 leaves. Also, update the constants \", _jsx(_components.code, {\n        children: \"LEVELS\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"MAX_SIZE\"\n      }), \" \", _jsx(_components.a, {\n        href: \"https://github.com/Turupawn/Huracan/blob/master/contracts/Huracan.sol#L16\",\n        children: \"in the contract\"\n      }), \". If your tree is very large, you can save gas on deployment by hardcoding the default values for an empty tree \", _jsx(_components.a, {\n        href: \"https://github.com/Turupawn/Huracan/blob/master/contracts/Huracan.sol#L33\",\n        children: \"instead of using a loop\"\n      }), \" as shown.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"f. Remember, Everything We Used Is in Experimental Stages\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The circuits and contracts in this guide are not properly audited, as are the libraries used. For example, Poseidon is a new hashing function that is promising and used instead of the traditional Pedersen.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Also, remember, this tutorial does not cover a secure trusted setup. It is recommended to conduct an open ceremony with sufficient time for participation.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"7. Ideas for Further Exploration\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"a. Exclusion Proofs\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Just as we handle inclusion proofs in this example, we can create exclusion proofs that \", _jsx(_components.em, {\n        children: \"demonstrate that we are not part of a blacklisted group\"\n      }), \". This could help in complying with future regulations that determine states.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"b. Use ERC20s Instead of Ether\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Instead of using Ether as the native currency in Solidity, you can use a specific ERC20 token. The changes would only be in the Solidity contracts and web app, while the circuits could remain the same.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"c. Experiment with Re-Staking\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Once you integrate ERC20s, a good next step might be to experiment with generating passive income using LSTs (Liquid Staking Tokens).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"d. Think of Other Use Cases!\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Anonymous inclusion proofs have many use cases, even beyond DeFi. Think about how you can apply what you’ve learned to voting systems, governance, social networks, video games, etc.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",
      "frontmatter": {},
      "scope": {}
    }
  }
]